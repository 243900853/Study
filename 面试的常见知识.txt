集合
Collection
ArrayList、LinkedList、Vector（线程安全）
ArrayList：底层是数组，初始化时，数据量是0，当add时候，默认变成10，扩容机制是上一次容量的1.5倍，特性查询比较快（通过脚标去查），删除效率低
LinkedList：底层是头结点和尾节点的双向链表，提供了2个方法，头插法LinkedFirst，尾插法LinkedLast，特性非常适用于经常增加和删除的场景，查询效率慢(他会对各个节点进行比较得到查询数据)
Vector：线程安全，底层和arrayList一样是数组，和ArrayList的区别在于，大部分方法都是被synchronized关键字所修饰，扩容机制是上一次容量的2倍

set
HashSet

map
HashMap、ConcurrentHashMap线程安全、HashTable线程安全
hashmap：
1.7版本--底层是数组+单链表  
1.8版本--数组+单链表+红黑树
1、单链表和红黑色之间的转换，单链表长度>=8，并且哈希桶数组长度>=64，会将单链表转换成红黑树形式进行存储，红黑树节点数量<=6，会重新转换成单链表
2、hash桶数组默认是16个，阈值默认是0.75，当插入16*0.75=12个元素的时候(简单理解为，已经有12个数组被占用)，就会触发扩容
3、扩容机制是上一次容量的2倍，然后重新进行新的hash运算(hash值 & （length -1）),填充到新的hash桶数组
4、链表扩容的数据迁移是将相同下标的节点组合在一起，放到新数组里面；红黑色是直接转移根节点

ConcurrentHashMap
线程安全，实现分段锁表
1.7版本--底层分片数组，为了保障线程安全，用到了Segment锁，他继承于ReentrantLock
1.8版本--数组+单链表+红黑树，使用synchronized+CAS操作来保证线程安全，里面有2把锁，第一把锁

HashTable
线程安全，全局锁表

CAS
1、compare and swap的缩写，中文翻译成比较并替换
2、CAS(内存值V，旧的预期值A，要修改的新值B)
3、相当于轻量级的加锁过程，在并发量不是特别大的情况下，当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做

CAS存在问题：
1、CPU开销大；自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销
2、只能保证一个共享变量原子操作；对多个共享变量操作时，循环CAS就无法保证操作的原子性
3、ABA-标志位 时间戳；如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。ABA问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加一，那么A－B－A 就会变成1A-2B－3A。

synchronized
synchronized关键字在编译之后会在同步代码块前后加入2个指令：
1、monitorenter(锁)
2、monitorexit(解锁)

偏向锁加锁：
1、将线程id写入到锁对象的对象头中
2、其他线程进入并获取锁之后，锁对象会结束偏向状态，膨胀成轻量锁或重量锁，有资源竞争重量锁，无资源竞争轻量锁

轻量级锁加锁：
1、执行monitorenter(锁)
2、新线程进来会在虚拟栈中为当前线程开辟一个空间叫Lock Record
3、将锁对象的Mark Word写入里面
4、CAS尝试将锁对象的Mark Word轻量级锁指针指向当前Lock Record（作用是让其他线程知道，该object monitor已被占用），成功获取锁，失败则挂起线程
5、然后lock record里的owner指针指向object mark word（作用是为了在接下里的运行过程中，识别哪个对象被锁住了）
6、执行monitorexit(解锁)

重量级锁同步代码块加锁：synchronized(o)
1、执行monitorenter(锁)
2、偏向锁膨胀成重量锁的过程，偏向锁会先进行撤销偏向成无锁01，此时锁对象的监视器锁monitor为0
3、新的线程获取锁，锁对象的monitor监视器锁会+1（锁支持重入），当前线程成为monitor的owner（所有者），并将monitor的指针写入到锁对象头
4、修改锁对象标志位为10，此时锁就膨胀成重量锁
5、若其他线程已经占有monitor的所有权，那么当前尝试获取monitor的所有权的线程会被阻塞，直到monitor的进入数变为0，才能重新尝试获取monitor的所有权。
6、执行monitorexit(解锁)
7、同步代码块执行完，加了几次锁释放几次，将monitor清零，完成释放锁

重量级锁同步方法加锁：public synchronized void test()
JVM使用ACC_SYNCHRONIZED标识来实现，即JVM通过在方法访问标识符(flags)中加入ACC_SYNCHRONIZED来实现同步功能。

volatile关键字
CPU和内存之间的线程效率是差好多数量级的，但为了保证他们之间的计算，不影响CPU的计算，中间会有好多LLV缓存，
我们线程在这个缓存中去工作，首先他取数据会在主内存取到工作内存中去计算，计算完之后在传给主内存，此时就出现了多线程间变量的可见性，
java为了解决这种问题，他就抽象出了JMM这种模型，
被volatile修饰的变量，保证变量能在多线程之间的可见性，也就是变量被更新了，能立刻刷新到主内存中，其他线程能立刻取到最新的变量数据，这是总线嗅探机制，
但不保证原子性，简单的说就是保证线程修改了变量能及时被其他线程看到，但不保证多个线程改变同一个变量之后数据的完整。
如何保障数据原子性：使用synchronized关键字、ReentrantLock加锁、AtomicXXX类（多个AtomicXXX类连续调用不能构成原子性）来保证数据原子性

总线嗅探机制：每个处理器通过嗅探在总线上传播的数据来检查自己的缓存值是不是过期了，如果处理器发现自己缓存行对应的内存地址呗修改，就会将当前处理器的缓存行设置无效状态
总线风暴：由于volatile的mesi缓存一致性协议需要不断的从主内存嗅探和cas不断循环无效交互导致总线带宽达到峰值 解决办法：部分volatile和cas使用synchronize
mesi缓存一致性协议：当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取。
资料：https://zhuanlan.zhihu.com/p/137193948









