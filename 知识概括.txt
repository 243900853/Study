SpringMVC
1、tomcat实现servlet的spi规范
 1.1 tomcat找到ServletContainerInitializer的实现类，并调用onStartup方法
 1.2 Spring的SpringServletContainerInitializer类继承了ServletContainerInitializer类，重写onStartup方法，SpringServletContainerInitializer这个类只用循环调用子类的onStartup方法。
 1.3 tomcat调用Spring的SpringServletContainerInitializer.onStartup方法
2、tomcat启动时会在实现SpringServletContainerInitializer子类的onStartup方法中，扫描并加载web.xml配置文件
3、web.xml配置文件配置spring-mvc.xml
4、web.xml会加载DispatcherServlet
5、DispatcherServlet扫描spring-mvc.xml的配置文件，扫描整个项目，根据配置文件给定的目录来扫描
6、扫描所有加了@Controller注解的类
7、当扫描到加了@Controller注解的类之后遍历里面所有的方法
8、拿到方法对象之后，解析方法上面是否加了@RequestMapping注解
9、定义一个map集合（Map<String,Method>），把@RequestMapping的value与方法对象绑定起来
10、拦截到请求之后，拿到请求的URI
11、拿URI去Map里面去get，找到方法
12、消息转换器处理，扫描方法里面的参数，然后根据request.getParameterNames()获取到前台传过来的参数，通过java反射对参数进行赋值
13、视图解析器处理。如果方法加了@ResponseBody，则进行resp.getWriter().write(result)直接将数据通过Response返回出去，如果是ModelAndView则进行视图的处理；如果是String，则通过请求转发req.getRequestDispatcher(前缀+String.valueOf(result)+后缀).forward(req,resp)进行页面跳转；


Dubbo
生产者
1、生产者提供接口，供消费者使用
2、生产者实现接口，处理业务逻辑
3、生产者服务注册，zookeeper注册或者本地注册
	3.1、注册中心远程服务注册：定义map集合，Map<存放接口名,接口实现类对应的URL地址>
	3.2、本地服务注册：定义map集合，Map<存放接口名,实现类>
4、生产者启动web容器
	4.1、tomcat拦截所有http请求
	4.2、反序列化获取http请求的参数（接口名、方法名、方法参数类型列表、方法值列表）
	4.3、接口名获取实现类，方法名和方法参数获取方法
	4.4、反射实例类，并执行方法，传入方法值
	4.5、Response返回结果数据给http请求

消费者
1、消费者传入远程服务信息
2、动态代理接口
	2.1、通过接口名获取远程服务信息集合
	2.2、负载均衡随机获取一台远程服务
	2.3、序列化请求信息
	2.4、发送http请求
	2.5、获取服务返回数据
3、获取实现类信息

消费者通过接口名向注册中心获取到接口实现类的路径，解析路径，看是通过dubbo协议发送请求还是通过http发送请求
传递接口参数
通过java反射技术进行实例化
通过spi来实现协议的动态处理


SpringBoot自动配置原理
1、@SpringBootApplication注解
2、@EnableAutoConfiguration注解
3、@Import(EnableAutoConfigurationImportSelector.class)
EnableAutoConfigurationImportSelector extend SelectImports
4、EnableAutoConfigurationImportSelector.selectImports方法里面SpringFactoriesLoader.loadFactoryNames方法去加载并解析META-INF/spring.factories这个配置文件
5、spring.factories这个文件的主要功能是存放需要注入到Spring容器中的class路径信息，以Key=Value形式存放，多个Value时使用,隔开，例如：
org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
自己需要注入到Spring容器的Class对象路径
6、真正使自动配置生效的key是org.springframework.boot.autoconfigure.EnableAutoConfiguration
7、Spring的自动配置文件在spring-boot-autoconfigure/META-INF/spring.factories下面

自己项目想要集成Spring步骤
1、创建自己的starter项目
2、引入自己的项目
3、引入Spring自动配置项目spring-boot-autoconfigure
4、在starter项目创建指定文件/META-INF/spring.factories
5、org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
自己需要注入到Spring容器的Class对象路径


Seata流程
TC:seata提供的事务管理中心。
TM:事务的发起者，并且最终与tc通信告诉事务的成功与否
RM:单个的微服务，也就是最终的资源管理者

1.TM 向 TC 申请开启一个全局事务，TC 创建全局事务后返回全局唯一的 XID，XID 会在全局事务的上下文中传播
	1.1 开启全局事务的入口：GlobalTransactionScanner extends AbstractAutoProxyCreator implements InitializingBean, ApplicationContextAware
	1.2 AbstractAutoProxyCreator.wrapIfNecessary方法作用：为了解决单例bean之间的循环依赖问题，提前将代理Bean对象暴露出去，也就是程序如果需要代理Bean，就可以通过这个方式获取到Bean数据，执行自己代理Bean逻辑并返回出去
		1.2.1 往global_table表插入一条全局事务记录数据
		1.2.2 创建全局事务后返回全局唯一的 XID
	1.3 InitializingBean.afterPropertiesSet方法作用：初始化Netty客户端
2.RM 向 TC 注册分支事务，该分支事务归属于拥有相同 XID 的全局事务
	2.1 往branch_table表插入一条分支事务数据，每个操作数据库的微服务插入一条
		2.2.1 怎么确保每个操作数据库的微服务都插入一条?此时就用到了DataSourceProxy这个代理数据源
		2.2.2 DataSourceProxy代理数据源的主要功能是在执行本地sql前，插入业务逻辑，这样就能做到拦截每个操作数据库的微服务
		2.2.3 此时不是所有的微服务都拦截，DataSourceProxy里面的逻辑只拦截在全局事务里面的分支事务，判断标准就是有没有XID
	2.2 往lock_table表插入一条数据，存放被锁住的对应数据源，防止多线程操作数据源导致赃数据
	2.3 执行前置镜像，保存数据库操作前数据源
	2.4 执行本地sql，操作数据库，不提交事务
	2.5 执行后置镜像，保存数据库操作后数据源
	2.6 RM 向 TC 注册分支事务，该分支事务归属于拥有相同 XID 的全局事务
	2.7 前置镜像和后置镜像的返回结果组装成undoLog对象，插入到undo_log表中，不提交事务
	2.8 本地sql、undo_log表数据一起提交事务
	2.9 向 TC 报告一阶段执行情况
3.TM 向 TC 发起全局提交或回滚；
4.TC 调度 XID 下的分支事务完成提交或者回滚。
