SpringMVC
1、tomcat实现servlet的spi规范
 1.1 tomcat找到ServletContainerInitializer的实现类，并调用onStartup方法
 1.2 Spring的SpringServletContainerInitializer类继承了ServletContainerInitializer类，重写onStartup方法，SpringServletContainerInitializer这个类只用循环调用子类的onStartup方法。
 1.3 tomcat调用Spring的SpringServletContainerInitializer.onStartup方法
2、tomcat启动时会在实现SpringServletContainerInitializer子类的onStartup方法中，扫描并加载web.xml配置文件
3、web.xml配置文件配置spring-mvc.xml
4、web.xml会加载DispatcherServlet
5、DispatcherServlet扫描spring-mvc.xml的配置文件，扫描整个项目，根据配置文件给定的目录来扫描
6、扫描所有加了@Controller注解的类
7、当扫描到加了@Controller注解的类之后遍历里面所有的方法
8、拿到方法对象之后，解析方法上面是否加了@RequestMapping注解
9、定义一个map集合（Map<String,Method>），把@RequestMapping的value与方法对象绑定起来
10、拦截到请求之后，拿到请求的URI
11、拿URI去Map里面去get，找到方法
12、消息转换器处理，扫描方法里面的参数，然后根据request.getParameterNames()获取到前台传过来的参数，通过java反射对参数进行赋值
13、视图解析器处理。如果方法加了@ResponseBody，则进行resp.getWriter().write(result)直接将数据通过Response返回出去，如果是ModelAndView则进行视图的处理；如果是String，则通过请求转发req.getRequestDispatcher(前缀+String.valueOf(result)+后缀).forward(req,resp)进行页面跳转；


Dubbo
生产者
1、生产者提供接口，供消费者使用
2、生产者实现接口，处理业务逻辑
3、生产者服务注册，zookeeper注册或者本地注册
	3.1、注册中心远程服务注册：定义map集合，Map<存放接口名,接口实现类对应的URL地址>
	3.2、本地服务注册：定义map集合，Map<存放接口名,实现类>
4、生产者启动web容器
	4.1、tomcat拦截所有http请求
	4.2、反序列化获取http请求的参数（接口名、方法名、方法参数类型列表、方法值列表）
	4.3、接口名获取实现类，方法名和方法参数获取方法
	4.4、反射实例类，并执行方法，传入方法值
	4.5、Response返回结果数据给http请求

消费者
1、消费者传入远程服务信息
2、动态代理接口
	2.1、通过接口名获取远程服务信息集合
	2.2、负载均衡随机获取一台远程服务
	2.3、序列化请求信息
	2.4、发送http请求
	2.5、获取服务返回数据
3、获取实现类信息

消费者通过接口名向注册中心获取到接口实现类的路径，解析路径，看是通过dubbo协议发送请求还是通过http发送请求
传递接口参数
通过java反射技术进行实例化
通过spi来实现协议的动态处理


SpringBoot自动配置原理
1、@SpringBootApplication注解
2、@EnableAutoConfiguration注解
3、@Import(EnableAutoConfigurationImportSelector.class)
EnableAutoConfigurationImportSelector extend SelectImports
4、EnableAutoConfigurationImportSelector.selectImports方法里面SpringFactoriesLoader.loadFactoryNames方法去加载并解析META-INF/spring.factories这个配置文件
5、spring.factories这个文件的主要功能是存放需要注入到Spring容器中的class路径信息，以Key=Value形式存放，多个Value时使用,隔开，例如：
org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
自己需要注入到Spring容器的Class对象路径
6、真正使自动配置生效的key是org.springframework.boot.autoconfigure.EnableAutoConfiguration
7、Spring的自动配置文件在spring-boot-autoconfigure/META-INF/spring.factories下面

自己项目想要集成Spring步骤
1、创建自己的starter项目
2、引入自己的项目
3、引入Spring自动配置项目spring-boot-autoconfigure
4、在starter项目创建指定文件/META-INF/spring.factories
5、org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
自己需要注入到Spring容器的Class对象路径


Seata AT模式流程
Seata可以管理TM、全局、分支、undo_log事务，不能管理不在TM下的其他微服务
TC:Seata提供的事务管理中心。
TM:事务的发起者，并且最终与tc通信告诉事务的成功与否
RM:单个的微服务，也就是最终的资源管理者

1.TM 向 TC 申请开启一个全局事务，TC 创建全局事务后返回全局唯一的 XID，XID 会在全局事务的上下文中传播
	1.1 开启全局事务的入口：GlobalTransactionScanner extends AbstractAutoProxyCreator implements InitializingBean, ApplicationContextAware
	1.2 AbstractAutoProxyCreator.wrapIfNecessary方法作用：为了解决单例bean之间的循环依赖问题，提前将代理Bean对象暴露出去，也就是程序如果需要代理Bean，就可以通过这个方式获取到Bean数据，执行自己代理Bean逻辑并返回出去
		1.2.1 往global_table表插入一条全局事务记录数据
		1.2.2 创建全局事务后返回全局唯一的 XID
	1.3 InitializingBean.afterPropertiesSet方法作用：初始化Netty客户端
2.RM 向 TC 注册分支事务，该分支事务归属于拥有相同 XID 的全局事务
	2.1 执行前置镜像，保存数据库操作前数据源。拼接sql-->select 列名 from 表 where 本地sql条件 for update;
	2.2 执行本地sql，操作数据库，不提交事务
	2.3 执行后置镜像，保存数据库操作后数据源
	2.4 RM 向 TC 注册分支事务，该分支事务归属于拥有相同 XID 的全局事务，XID的数据通过request.header请求头传到各个微服务，然后各个微服务保存起来
		2.4.1 往branch_table表插入一条分支事务数据，每个操作数据库的微服务插入一条
		2.4.2 怎么确保每个操作数据库的微服务都往branch_table表插入一条?此时就用到了DataSourceProxy这个代理数据源
		2.4.3 DataSourceProxy代理数据源的主要功能是在执行本地sql前，插入业务逻辑，这样就能做到拦截每个操作数据库的微服务
		2.4.4 此时不是所有的微服务都拦截，DataSourceProxy里面的逻辑只拦截在全局事务里面的分支事务，判断标准就是有没有XID,没有XID则直接调用业务方法
		2.4.5 本地sql查出来1条数据，就往lock_table表插入一条id为“表名：id”的数据，存放被锁住的对应数据源，防止多线程操作数据源导致赃数据
		2.4.5 防止脏读：@GlobalTransaction + for update
		2.4.6 防止脏写：@GlobalLock
		2.4.7 Seata是怎么保证分布式事务和分布式事务/分布式事务和本地事务的隔离性？用到全局锁
			2.4.7.1 当分布式事务在操作数据库前，会根据自己的xid查询一次branch_table表数据
			2.4.7.2 如果找到，则允许操作数据库，同时往lock_table表记录操作哪些数据（剔除lock_table表重复操作记录）
			2.4.7.3 如果没找到，则会去lock_table表查一次
			2.4.7.4 没找到，证明不在同一个事务里面，并且操作的也不是同一条记录，运行操作数据库
			2.4.7.5 找到了，证明不在同一个事务里面，但是操作有被其他事务锁住的记录，则会抛出异常，客户端接收到这个消息后，会进行重试操作，执行30次，每次间隔10毫秒，重试不成功则进行全局回滚。
	2.7 前置镜像和后置镜像的返回结果组装成undoLog对象，插入到undo_log表中(一个分支事务一条undo_log数据)，不提交事务
	2.8 本地sql事务、undo_log表事务一起提交
	2.9 向 TC 报告一阶段执行情况，改变分支事务状态。
3.TM 向 TC 发起全局提交或回滚；
	3.1 在注册分支事务时如果出现报错，则进行全局回滚
4.TC 调度 XID 下的分支事务完成提交或者回滚。
	4.1 客户端分支事务提交给服务端之后，服务端异步处理数据
		4.1.1 服务端根据xid(全局事务id)和branch_id(分支事务id)删除lock_table表数据
		4.1.2 服务端根据xid(全局事务id)和branch_id(分支事务id)删除branch_table表数据，同时发送一条删除undo_log表消息给客户端，客户端将这些消息加入到队列
		4.1.3 客户端定时任务处理删除undo_log数据，当队列达到1000的情况下就先删除一次，否则就全部删除
		4.1.4 分支事务表删除完之后，服务端根据xid(全局事务id)删除global_table表数据
		4.1.5 表数据都删除完之后在进行全局事务提交

Tomcat工作流程
1、linux系统内部会实现tcp协议，通过socket连接对外提供接口访问方法。
2、客户端会按照http协议将数据拼接好，跟操作系统进行tcp协议数据传输，tomcat通过http协议规范解析tcp传输过来的数据。
3、tomcat通过socket获取到tcp传输过来的数据，他会先根据配置文件判断要使用那种协议处理器去解析传输过来的http协议数据。
4、如果使用bio模型就是用JioEndPoint去解析，如果是nio就是NioEndPoint去解析，如果是其他的就是用其他的Endpoint去解析socket传输过来的数据。
5、EndPoint会将数据解析成请求头、请求行、请求体然后封装成Request对象传到Servlet