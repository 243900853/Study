SpringMVC
1、tomcat实现servlet的spi规范
 1.1 tomcat找到ServletContainerInitializer的实现类，并调用onStartup方法
 1.2 Spring的SpringServletContainerInitializer类继承了ServletContainerInitializer类，重写onStartup方法，SpringServletContainerInitializer这个类只用循环调用子类的onStartup方法。
 1.3 tomcat调用Spring的SpringServletContainerInitializer.onStartup方法
2、tomcat启动时会在实现SpringServletContainerInitializer子类的onStartup方法中，扫描并加载web.xml配置文件
3、web.xml配置文件配置spring-mvc.xml
4、web.xml会加载DispatcherServlet
5、DispatcherServlet扫描spring-mvc.xml的配置文件，扫描整个项目，根据配置文件给定的目录来扫描
6、扫描所有加了@Controller注解的类
7、当扫描到加了@Controller注解的类之后遍历里面所有的方法
8、拿到方法对象之后，解析方法上面是否加了@RequestMapping注解
9、定义一个map集合（Map<String,Method>），把@RequestMapping的value与方法对象绑定起来
10、拦截到请求之后，拿到请求的URI
11、拿URI去Map里面去get，找到方法
12、消息转换器处理，扫描方法里面的参数，然后根据request.getParameterNames()获取到前台传过来的参数，通过java反射对参数进行赋值
13、视图解析器处理。如果方法加了@ResponseBody，则进行resp.getWriter().write(result)直接将数据通过Response返回出去，如果是ModelAndView则进行视图的处理；如果是String，则通过请求转发req.getRequestDispatcher(前缀+String.valueOf(result)+后缀).forward(req,resp)进行页面跳转；


Dubbo
生产者实现接口，并向注册中心提供接口路径和实现类
消费者获取接口，动态代理接口
消费者通过接口名向注册中心获取到接口实现类的路径，解析路径，看是通过dubbo协议发送请求还是通过http发送请求
传递接口参数
通过java反射技术进行实例化
通过spi来实现协议的动态处理


SpringBoot自动配置原理
1、@SpringBootApplication注解
2、@EnableAutoConfiguration注解
3、@Import(EnableAutoConfigurationImportSelector.class)
EnableAutoConfigurationImportSelector extend SelectImports
4、EnableAutoConfigurationImportSelector.selectImports方法里面SpringFactoriesLoader.loadFactoryNames方法去加载并解析META-INF/spring.factories这个配置文件
5、spring.factories这个文件的主要功能是存放需要注入到Spring容器中的class路径信息，以Key=Value形式存放，多个Value时使用,隔开，例如：
org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
自己需要注入到Spring容器的Class对象路径
6、真正使自动配置生效的key是org.springframework.boot.autoconfigure.EnableAutoConfiguration
7、Spring的自动配置文件在spring-boot-autoconfigure/META-INF/spring.factories下面

自己项目想要集成Spring步骤
1、创建自己的starter项目
2、引入自己的项目
3、引入Spring自动配置项目spring-boot-autoconfigure
4、在starter项目创建指定文件/META-INF/spring.factories
5、org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
自己需要注入到Spring容器的Class对象路径

Seata流程：
TC:seata提供的事务管理中心。
TM:事务的发起者，并且最终与tc通信告诉事务的成功与否
RM:单个的微服务，也就是最终的资源管理者

1.TM 向 TC 申请开启一个全局事务，TC 创建全局事务后返回全局唯一的 XID，XID 会在全局事务的上下文中传播
	1.1 开启全局事务的入口：GlobalTransactionScanner extends AbstractAutoProxyCreator implements InitializingBean, ApplicationContextAware
	1.2 AbstractAutoProxyCreator.wrapIfNecessary方法作用：为了解决单例bean之间的循环依赖问题，提前将代理Bean对象暴露出去，也就是程序如果需要代理Bean，就可以通过这个方式获取到Bean数据，执行自己代理Bean逻辑并返回出去
		1.2.1 往global_table表插入一条全局事务记录数据
		1.2.2 创建全局事务后返回全局唯一的 XID
	1.3 InitializingBean.afterPropertiesSet方法作用：初始化Netty客户端
2.RM 向 TC 注册分支事务，该分支事务归属于拥有相同 XID 的全局事务
	2.1 往branch_table表插入一条分支事务数据，每个操作数据库的微服务插入一条
		2.2.1 怎么确保每个操作数据库的微服务都插入一条?此时就用到了DataSourceProxy这个代理数据源
		2.2.2 DataSourceProxy代理数据源的主要功能是在执行本地sql前，插入业务逻辑，这样就能做到拦截每个操作数据库的微服务
		2.2.3 此时不是所有的微服务都拦截，DataSourceProxy里面的逻辑只拦截在全局事务里面的分支事务，判断标准就是有没有XID
	2.2 往lock_table表插入一条数据，存放被锁住的对应数据源，防止多线程操作数据源导致赃数据
	2.3 执行前置镜像，保存数据库操作前数据源
	2.4 执行本地sql，操作数据库，不提交事务
	2.5 执行后置镜像，保存数据库操作后数据源
	2.6 RM 向 TC 注册分支事务，该分支事务归属于拥有相同 XID 的全局事务
	2.7 前置镜像和后置镜像的返回结果组装成undoLog对象，插入到undo_log表中，不提交事务
	2.8 本地sql、undo_log表数据一起提交事务
	2.9 向 TC 报告一阶段执行情况
3.TM 向 TC 发起全局提交或回滚；
4.TC 调度 XID 下的分支事务完成提交或者回滚。